<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MP4クリッパー（試作）</title>
  <meta name="description" content="PyQt5 + OpenCVでテンプレ画像一致を検出し、MP4から区間を自動でクリップ化する試作ツールの紹介ページ。" />
  <link rel="stylesheet" href="cliper.css" />
</head>

<body>
  <header class="hero">
    <div class="container hero__inner">
      <div class="badge">試作</div>
      <h1>MP4クリッパー</h1>
      <p class="lead">
        テンプレ画像の一致を検出して、MP4動画から一致区間を自動で切り出すツール（試作）。
      </p>

      <nav class="hero__cta" aria-label="ページ内リンク">
        <a class="btn btn--primary" href="#features">機能</a>
        <a class="btn" href="#limits">うまくいかなかった点</a>
        <a class="btn" href="#source">ソースコード</a>
      </nav>

      <div class="hero__meta" role="list">
        <div class="metaCard" role="listitem">
          <div class="metaCard__label">UI</div>
          <div class="metaCard__value">PyQt5</div>
        </div>
        <div class="metaCard" role="listitem">
          <div class="metaCard__label">検出</div>
          <div class="metaCard__value">cv2.matchTemplate</div>
        </div>
        <div class="metaCard" role="listitem">
          <div class="metaCard__label">出力</div>
          <div class="metaCard__value">clips/*.mp4</div>
        </div>
      </div>
    </div>
  </header>

  <main class="container">
    <section id="overview" class="section">
      <h2>概要</h2>
      <p>
        任意のMP4動画に対して、特定のUI・アイコン・通知などの「見た目」をテンプレ画像として指定し、
        動画内で一致度が閾値を超えたフレームを集めて連続区間をセグメント化します。
        その区間を個別のmp4として切り出して保存します。
      </p>

      <div class="callout">
        <p class="callout__title">注意</p>
        <p class="callout__text">
          これは試作です。動作は確認できたものの、安定運用には課題が残りました（後述）。
        </p>
      </div>
    </section>

    <section id="features" class="section">
      <h2>できること</h2>

      <div class="grid">
        <article class="card">
          <h3>動画とテンプレ画像を選ぶ</h3>
          <p>MP4動画と、PNG/JPGのテンプレ画像をGUIから選択します。</p>
          <ul class="list">
            <li>動画：*.mp4</li>
            <li>テンプレ：*.png / *.jpg / *.jpeg</li>
          </ul>
        </article>

        <article class="card">
          <h3>閾値（threshold）を調整</h3>
          <p>
            一致判定の閾値をスライダーで調整（0.00〜1.00）。
            値が高いほど厳しめ、低いほど拾いやすくなります。
          </p>
        </article>

        <article class="card">
          <h3>一致区間を検出して切り出し</h3>
          <p>一致したフレームを連結してセグメント化し、clips/に連番で保存します。</p>
          <div class="code">
            clips/clip_1.mp4<br />
            clips/clip_2.mp4<br />
            ...
          </div>
        </article>

        <article class="card">
          <h3>進捗表示（改良版）</h3>
          <p>
            main2.pyではQThreadを使い、処理中でもUIが固まりにくいようにしています。
            進捗%もラベルに反映します。
          </p>
        </article>
      </div>
    </section>

    <section id="workflow" class="section">
      <h2>使い方（ざっくり）</h2>
      <ol class="steps">
        <li><span class="stepNum">1</span> MP4動画を選択</li>
        <li><span class="stepNum">2</span> テンプレ画像を選択</li>
        <li><span class="stepNum">3</span> 閾値を調整</li>
        <li><span class="stepNum">4</span> 実行 → clips/に書き出し</li>
      </ol>
    </section>

    <section id="limits" class="section section--danger">
      <h2>うまくいかなかったこと（重要）</h2>

      <div class="dangerBox">
        <h3>狙い通りに抽出できなかった & とにかく遅かった</h3>
        <div class="dangerGrid">
          <div class="dangerItem">
            <div class="dangerItem__title">閾値調整を手動でやる必要がある</div>
            <div class="dangerItem__text">
              threshold（閾値）に強く依存し、毎回スライダーで試行錯誤が必要でした。
              その結果、狙いの画像（場面）を安定して抽出できないことがありました。
            </div>
          </div>

          <div class="dangerItem">
            <div class="dangerItem__title">処理速度がめちゃくちゃ遅い</div>
            <div class="dangerItem__text">
              全フレームで照合処理を回すため、長尺動画だと待ち時間が大きくなりました。
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="source" class="section">
      <h2>ソースコード</h2>
      <p class="note">折りたたみ（開閉）形式で掲載します。</p>

      <details class="details">
        <summary><span class="details__title">main.py（シンプル版）</span><span class="details__meta">開閉</span></summary>
        <pre class="pre"><code class="language-python">import sys
from PyQt5.QtWidgets import(
    QApplication, QWidget, QVBoxLayout, QPushButton, QLabel, QFileDialog, QSlider, QLineEdit
)
from PyQt5.QtCore import Qt
from matcher import find_matching_segments, export_clips

class App(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('MP4クリッパー')
        self.setGeometry(100, 100, 400, 300)

        # 初期値
        self.video_path = None
        self.template_path = None
        self.threshold = 0.8

        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        self.video_label = QLabel('動画ファイル：未選択')
        self.video_btn = QPushButton('動画を選択')
        self.video_btn.clicked.connect(self.select_video)

        self.template_label = QLabel('テンプレ画像：未選択')
        self.template_btn = QPushButton('テンプレ画像を選択')
        self.template_btn.clicked.connect(self.select_template)

        self.threshold_label = QLabel('閾値')
        self.threshold_input = QLineEdit('0.8')
        self.threshold_input.setReadOnly(True)

        self.threshold_slider = QSlider(Qt.Horizontal)
        self.threshold_slider.setMinimum(0)
        self.threshold_slider.setMaximum(100)
        self.threshold_slider.setValue(int(self.threshold * 100))
        self.threshold_slider.valueChanged.connect(self.update_threshold)

        self.run_btn = QPushButton('実行')
        self.run_btn.clicked.connect(self.run_detection)

        self.progress_label = QLabel("進行状況: 0%")

        layout.addWidget(self.progress_label)
        layout.addWidget(self.video_label)
        layout.addWidget(self.video_btn)
        layout.addWidget(self.template_label)
        layout.addWidget(self.template_btn)
        layout.addWidget(self.threshold_label)
        layout.addWidget(self.threshold_input)
        layout.addWidget(self.threshold_slider)
        layout.addWidget(self.run_btn)

        self.setLayout(layout)

    def select_video(self):
        file, _ = QFileDialog.getOpenFileName(self, '動画ファイルを選択', '', 'MP4 files (*.mp4);;すべてのファイル (*.*)')
        if file:
            self.video_path = file
            self.video_label.setText(f"動画ファイル: {file}")

    def select_template(self):
        file, _ = QFileDialog.getOpenFileName(self, 'テンプレ画像', '', '画像ファイル (*.png *.jpg *.jpeg);;すべてのファイル (*.*)')
        if file:
            self.template_path = file
            self.template_label.setText(f"テンプレ画像: {file}")

    def run_detection(self):
        if not self.video_path:
            print('error: 動画ファイルが選ばれていません')
            return
        elif not self.template_path:
            print('error: テンプレ画像が選ばれていません')
            return

        print(f"done: 動画: {self.video_path}")
        print(f"done: テンプレ画像: {self.template_path}")
        print("映像解析を始めます...")

        segments = find_matching_segments(
            self.video_path,
            self.template_path,
            threshold=self.threshold,
            min_length=10,
            progress_callback=self.update_progress
        )

        if not segments:
            print("⚠️ 一致セグメントが見つかりませんでした。")
            return

        export_clips(self.video_path, segments, output_dir="clips")
        print("✅ すべてのクリップを保存しました！clips/フォルダを確認してください。")
        self.update_progress(100.0)

    def update_threshold(self, value):
        self.threshold = value / 100.0
        self.threshold_input.setText(f"{self.threshold:.2f}")

    def update_progress(self, percent):
        self.progress_label.setText(f"進行状況: {percent:.1f}%")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = App()
    win.show()
    sys.exit(app.exec_())</code></pre>
      </details>

      <details class="details">
        <summary><span class="details__title">main2.py（スレッド版）</span><span class="details__meta">開閉</span></summary>
        <pre class="pre"><code class="language-python">import sys
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QPushButton, QLabel,
    QFileDialog, QSlider, QLineEdit
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from matcher import find_matching_segments, export_clips

class WorkerThread(QThread):
    progress = pyqtSignal(float)
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, video_path, template_path, threshold):
        super().__init__()
        self.video_path = video_path
        self.template_path = template_path
        self.threshold = threshold

    def run(self):
        try:
            segments = find_matching_segments(
                self.video_path,
                self.template_path,
                threshold=self.threshold,
                min_length=10,
                progress_callback=self.progress.emit
            )

            if not segments:
                self.error.emit("一致セグメントが見つかりませんでした。")
                return

            export_clips(self.video_path, segments, output_dir="clips")
            self.finished.emit()

        except Exception as e:
            self.error.emit(str(e))

class App(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('MP4クリッパー')
        self.setGeometry(100, 100, 400, 350)

        self.video_path = None
        self.template_path = None
        self.threshold = 0.8
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        self.video_label = QLabel('動画ファイル：未選択')
        self.video_btn = QPushButton('動画を選択')
        self.video_btn.clicked.connect(self.select_video)

        self.template_label = QLabel('テンプレ画像：未選択')
        self.template_btn = QPushButton('テンプレ画像を選択')
        self.template_btn.clicked.connect(self.select_template)

        self.threshold_label = QLabel('閾値')
        self.threshold_input = QLineEdit('0.8')
        self.threshold_input.setReadOnly(True)

        self.threshold_slider = QSlider(Qt.Horizontal)
        self.threshold_slider.setMinimum(0)
        self.threshold_slider.setMaximum(100)
        self.threshold_slider.setValue(int(self.threshold * 100))
        self.threshold_slider.valueChanged.connect(self.update_threshold)

        self.run_btn = QPushButton('実行')
        self.run_btn.clicked.connect(self.run_detection)

        self.progress_label = QLabel("進行状況: 0%")

        layout.addWidget(self.video_label)
        layout.addWidget(self.video_btn)
        layout.addWidget(self.template_label)
        layout.addWidget(self.template_btn)
        layout.addWidget(self.threshold_label)
        layout.addWidget(self.threshold_input)
        layout.addWidget(self.threshold_slider)
        layout.addWidget(self.run_btn)
        layout.addWidget(self.progress_label)

        self.setLayout(layout)

    def select_video(self):
        file, _ = QFileDialog.getOpenFileName(self, '動画ファイルを選択', '', 'MP4 files (*.mp4);;すべてのファイル (*.*)')
        if file:
            self.video_path = file
            self.video_label.setText(f"動画ファイル: {file}")

    def select_template(self):
        file, _ = QFileDialog.getOpenFileName(self, 'テンプレ画像を選択', '', '画像ファイル (*.png *.jpg *.jpeg);;すべてのファイル (*.*)')
        if file:
            self.template_path = file
            self.template_label.setText(f"テンプレ画像: {file}")

    def update_threshold(self, value):
        self.threshold = value / 100.0
        self.threshold_input.setText(f"{self.threshold:.2f}")

    def update_progress(self, percent):
        self.progress_label.setText(f"進行状況: {percent:.1f}%")

    def run_detection(self):
        if not self.video_path:
            print('error: 動画ファイルが選ばれていません')
            return
        if not self.template_path:
            print('error: テンプレ画像が選ばれていません')
            return

        self.progress_label.setText("進行状況: 0%")

        self.worker = WorkerThread(self.video_path, self.template_path, self.threshold)
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.detection_finished)
        self.worker.error.connect(self.detection_error)
        self.worker.start()

    def detection_finished(self):
        self.update_progress(100.0)
        print("✅ すべてのクリップを保存しました！clips/フォルダを確認してください。")

    def detection_error(self, message):
        print(f"❌ エラー発生: {message}")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = App()
    win.show()
    sys.exit(app.exec_())</code></pre>
      </details>

      <details class="details">
        <summary><span class="details__title">matcher.py（検出・書き出し）</span><span class="details__meta">開閉</span></summary>
        <pre class="pre"><code class="language-python">import cv2
import numpy as np
import os

def group_frames(frames, min_length=10):
    if not frames:
        return []

    segments = []
    start = None
    prev = -2

    for idx in frames:
        if idx != prev + 1:
            if start is not None and prev - start + 1 >= min_length:
                segments.append((start, prev))
            start = idx
        prev = idx

    if start is not None and prev - start + 1 >= min_length:
        segments.append((start, prev))

    return segments

def find_matching_segments(video_path, template_path, threshold=0.8, min_length=10, progress_callback=None):
    cap = cv2.VideoCapture(video_path)
    template = cv2.imread(template_path, 0)
    match_frames = []
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    frame_idx = 0

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        res = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)

        if np.max(res) >= threshold:
            match_frames.append(frame_idx)

        if progress_callback and frame_idx % 10 == 0:
            percent = (frame_idx / total_frames) * 100
            progress_callback(percent)

        frame_idx += 1

    cap.release()
    return group_frames(match_frames, min_length)

def export_clips(video_path, segments, output_dir='clips', prefix='clip'):
    cap = cv2.VideoCapture(video_path)

    fps = cap.get(cv2.CAP_PROP_FPS)
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

    os.makedirs(output_dir, exist_ok=True)

    for i, (start, end) in enumerate(segments):
        cap.set(cv2.CAP_PROP_POS_FRAMES, start)

        out_path = os.path.join(output_dir, f"{prefix}_{i+1}.mp4")
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        out = cv2.VideoWriter(out_path, fourcc, fps, (width, height))

        for _ in range(end - start + 1):
            ret, frame = cap.read()
            if not ret:
                break
            out.write(frame)
        out.release()

    cap.release()</code></pre>
      </details>
    </section>

    <footer class="footer">
      <p>MP4クリッパー（試作）</p>
    </footer>
  </main>
</body>
</html>

